# Spring Security 인증 및 인가 구현

Spring Security는 인증(Authentication)과 인가(Authorization) 기능을 제공하는 강력한 보안 프레임워크입니다. 간단히 말하자면, **인증**은 사용자가 누구인지 확인하는 과정이고, **인가**는 사용자가 특정 리소스나 작업을 수행할 수 있는 권한을 가지고 있는지를 결정하는 과정입니다.

## 1. 인증(Authentication)

**인증**은 사용자가 시스템에 접근할 때 "이 사람이 누구인지" 확인하는 과정입니다. 일반적으로 로그인 폼에서 사용자 이름과 비밀번호를 입력받아 이를 인증 처리합니다.

### 인증 절차
1. 사용자가 로그인 화면에서 **username**과 **password**를 입력합니다.
2. Spring Security는 `AuthenticationManager`를 통해 이를 처리합니다.
3. 사용자 정보가 데이터베이스에 저장된 정보와 일치하는지 검증하고, 일치하면 **Authentication 객체**가 생성됩니다.

### 인증 구현 코드 예시
```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/login", "/signup").permitAll() // 로그인, 회원가입 페이지는 인증 필요 없음
                .anyRequest().authenticated() // 다른 모든 페이지는 인증 필요
            .and()
            .formLogin()
                .loginPage("/login") // 로그인 페이지 설정
                .permitAll()
            .and()
            .logout()
                .permitAll(); // 로그아웃 설정
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
            .withUser("user").password("{noop}password").roles("USER") // 임시 사용자 설정
            .and()
            .withUser("admin").password("{noop}admin").roles("ADMIN"); // 임시 관리자 설정
    }
}
```

## 2. 인가(Authorization)

**인증**된 사용자가 리소스나 작업을 수행할 권한을 가지고 있는지를 결정하는 것이 **인가**입니다. Spring Security에서는 `@PreAuthorize`, `@Secured` 어노테이션을 사용하거나 HTTP 요청을 필터링하여 인가를 처리합니다.

### 인가 절차
1. 인증된 사용자가 특정 URL이나 메서드에 접근하려 할 때,
2. Spring Security는 해당 사용자의 **권한**(roles)이나 **그룹**(authorities)을 확인하고, 해당 요청을 처리할 수 있는지 여부를 결정합니다.

### 인가 구현 코드 예시

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/admin/**").hasRole("ADMIN") // /admin/** 경로는 ADMIN 권한만 허용
                .antMatchers("/user/**").hasRole("USER") // /user/** 경로는 USER 권한만 허용
                .anyRequest().authenticated() // 나머지 요청은 인증된 사용자만 접근 가능
            .and()
            .formLogin()
                .permitAll();
    }
}
```

## 3. 세션 관리 및 로그아웃

Spring Security는 세션을 관리할 수 있는 기능도 제공합니다. 예를 들어, 사용자가 인증 후 세션을 만료시키거나 세션 고정 공격을 방지할 수 있습니다.

### 세션 관리 설정

세션 고정 공격을 방지하고, 사용자 세션을 적절히 관리하는 방법에 대해 설정할 수 있습니다. 아래 예시에서는 세션 고정 공격 방지, 최대 세션 수 제한, 세션 만료 처리 등을 설정합니다.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .sessionManagement()
            .sessionFixation().newSession() // 세션 고정 공격 방지
            .maximumSessions(1) // 한 사용자당 한 세션만 허용
            .expiredUrl("/login?expired=true") // 세션 만료시 리다이렉트
        .and()
        .and()
        .logout()
            .logoutUrl("/logout") // 로그아웃 URL 설정
            .invalidateHttpSession(true) // 로그아웃 시 세션 무효화
            .clearAuthentication(true) // 인증 정보 삭제
            .permitAll();
}
```